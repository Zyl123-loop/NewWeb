<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>JD AR Hand Interaction</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        
        /* 
           关键修复：不能使用 display: none 
           改用 opacity: 0 和 z-index: -1 把它藏在画布后面
           这样浏览器认为视频正在播放，才会产生数据
        */
        #input-video { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            object-fit: cover;
            opacity: 0; 
            z-index: -1; 
        }
        
        canvas { display: block; position: absolute; top: 0; left: 0; }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 16px; z-index: 10; text-align: center;
            background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px;
            width: 80%; max-width: 300px;
        }
        #start-btn {
            display: none; margin-top: 20px; padding: 12px 24px;
            background: #e1251b; /* JD Red */
            color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;
            width: 100%;
        }
        #error-msg {
            color: #ff4d4f; margin-top: 10px; font-size: 12px; display: none;
        }
    </style>
    
    <!-- 引入 MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <!-- 移除了 camera_utils，使用原生 API -->
</head>
<body>

    <div id="loading">
        <div id="status-text">正在加载资源...</div>
        <div id="error-msg"></div>
        <button id="start-btn">开启摄像头体验</button>
    </div>

    <!-- 视频元素 (现在是隐藏但在渲染的) -->
    <video id="input-video" playsinline muted autoplay></video>
    
    <!-- 离屏 Canvas -->
    <canvas id="mask-canvas" style="display:none;"></canvas>
    <!-- 主 Canvas -->
    <canvas id="main-canvas"></canvas>

<script>
    const videoElement = document.getElementById('input-video');
    const canvas = document.getElementById('main-canvas');
    const ctx = canvas.getContext('2d');
    
    const maskCanvas = document.getElementById('mask-canvas');
    const maskCtx = maskCanvas.getContext('2d', { willReadFrequently: true });
    
    const loadingDiv = document.getElementById('loading');
    const statusText = document.getElementById('status-text');
    const startBtn = document.getElementById('start-btn');
    const errorMsg = document.getElementById('error-msg');

    let width, height;
    let particlesArray = [];
    let handMaskData = null;
    let cameraRunning = false;

    // 调整画布大小
    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        maskCanvas.width = width;
        maskCanvas.height = height;
        initParticles();
    }
    window.addEventListener('resize', resize);

    // ----------------------
    // 1. 粒子系统 (JD)
    // ----------------------
    class Particle {
        constructor(x, y) {
            this.originX = x; 
            this.originY = y;
            this.x = Math.random() * width; 
            this.y = Math.random() * height;
            this.size = 2;
            const colors = ['#e1251b', '#f5f5f5', '#ff9999']; 
            this.color = colors[Math.floor(Math.random() * colors.length)];
            this.vx = 0;
            this.vy = 0;
            this.friction = 0.92; 
            this.ease = 0.08; 
        }

        draw() {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }

        update() {
            let dx = this.originX - this.x;
            let dy = this.originY - this.y;
            
            let isTouchingHand = false;
            const pX = Math.floor(this.x);
            const pY = Math.floor(this.y);

            // 读取蒙版数据进行碰撞检测
            if (pX >= 0 && pX < width && pY >= 0 && pY < height && handMaskData) {
                const index = (pY * width + pX) * 4;
                if (handMaskData[index] > 100) {
                    isTouchingHand = true;
                }
            }

            if (isTouchingHand) {
                const angle = Math.random() * Math.PI * 2;
                const pushForce = 8; 
                this.vx += Math.cos(angle) * pushForce;
                this.vy += Math.sin(angle) * pushForce;
                this.size = 5;
            } else {
                this.vx += dx * this.ease * 0.1;
                this.vy += dy * this.ease * 0.1;
                this.size = (Math.abs(dx) < 1 && Math.abs(dy) < 1) ? 2 : 2.5;
            }

            this.vx *= this.friction;
            this.vy *= this.friction;
            this.x += this.vx;
            this.y += this.vy;
        }
    }

    function initParticles() {
        particlesArray = [];
        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = 'white';
        let fontSize = width / 2.5; 
        if (fontSize > 300) fontSize = 300;
        ctx.font = `900 ${fontSize}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('JD', width / 2, height / 2);

        const textCoordinates = ctx.getImageData(0, 0, width, height);
        // 如果卡顿，将 step 改大，比如 8 或 10
        const step = 6; 
        
        for (let y = 0; y < height; y += step) {
            for (let x = 0; x < width; x += step) {
                const alpha = textCoordinates.data[(y * 4 * textCoordinates.width) + (x * 4) + 3];
                if (alpha > 128) {
                    particlesArray.push(new Particle(x, y));
                }
            }
        }
        ctx.clearRect(0, 0, width, height);
    }

    // ----------------------
    // 2. MediaPipe Hands 逻辑
    // ----------------------
    function drawHandOnMask(landmarks) {
        maskCtx.fillStyle = 'white';
        maskCtx.strokeStyle = 'white';
        maskCtx.lineWidth = 40; 
        maskCtx.lineCap = 'round';
        maskCtx.lineJoin = 'round';

        const connections = [
            [0, 1], [1, 2], [2, 3], [3, 4],
            [0, 5], [5, 6], [6, 7], [7, 8],
            [0, 9], [9, 10], [10, 11], [11, 12],
            [0, 13], [13, 14], [14, 15], [15, 16],
            [0, 17], [17, 18], [18, 19], [19, 20],
            [5, 9], [9, 13], [13, 17]
        ];

        maskCtx.beginPath();
        for (let i = 0; i < connections.length; i++) {
            const start = landmarks[connections[i][0]];
            const end = landmarks[connections[i][1]];
            maskCtx.moveTo(start.x * width, start.y * height);
            maskCtx.lineTo(end.x * width, end.y * height);
        }
        maskCtx.stroke();
    }

    function onResults(results) {
        // 1. 绘制背景 (摄像头画面)
        ctx.save();
        ctx.translate(width, 0);
        ctx.scale(-1, 1);
        // 确保 image 存在
        if (results.image) {
            ctx.drawImage(results.image, 0, 0, width, height);
        }
        ctx.restore();

        // 背景遮罩
        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
        ctx.fillRect(0, 0, width, height);

        // 2. 绘制隐形蒙版 (手部)
        maskCtx.clearRect(0, 0, width, height);
        maskCtx.save();
        maskCtx.translate(width, 0);
        maskCtx.scale(-1, 1);
        if (results.multiHandLandmarks) {
            for (const landmarks of results.multiHandLandmarks) {
                drawHandOnMask(landmarks);
            }
        }
        maskCtx.restore();

        // 3. 提取碰撞数据
        handMaskData = maskCtx.getImageData(0, 0, width, height).data;

        // 4. 粒子更新
        particlesArray.forEach(p => {
            p.update();
            p.draw();
        });
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });
    hands.onResults(onResults);

    // ----------------------
    // 3. 摄像头启动与循环 (原生API修复版)
    // ----------------------
    async function startCamera() {
        try {
            statusText.innerText = "正在请求摄像头权限...";
            
            // 使用原生 getUserMedia
            const stream = await navigator.mediaDevices.getUserMedia({
                audio: false,
                video: {
                    facingMode: 'user', // 优先前置
                    // 不要设置具体的 width/height，让系统自动匹配最佳分辨率
                    // 这样可以避免某些手机因分辨率不支持而黑屏
                }
            });

            videoElement.srcObject = stream;
            
            // 等待视频元数据加载，确保能获取尺寸
            videoElement.onloadedmetadata = () => {
                videoElement.play();
                statusText.innerText = "初始化模型...";
                cameraRunning = true;
                processVideo(); // 开始逐帧处理
            };

        } catch (err) {
            console.error(err);
            statusText.innerText = "无法启动摄像头";
            errorMsg.style.display = 'block';
            errorMsg.innerText = "错误详情: " + err.name + " - " + err.message + "\n请确保在 HTTPS 环境下运行，并允许摄像头权限。";
        }
    }

    // 每一帧手动发送给 MediaPipe
    async function processVideo() {
        if (!cameraRunning) return;

        if (videoElement.currentTime > 0 && !videoElement.paused && !videoElement.ended) {
            try {
                // 将视频帧发给模型
                await hands.send({image: videoElement});
            } catch (error) {
                console.error("MediaPipe error:", error);
            }
        }
        // 循环调用
        requestAnimationFrame(processVideo);
    }

    // ----------------------
    // 4. 初始化
    // ----------------------
    hands.initialize().then(() => {
        statusText.innerText = "模型准备就绪";
        loadingDiv.appendChild(startBtn);
        startBtn.style.display = "inline-block";
    });

    startBtn.addEventListener('click', () => {
        loadingDiv.style.display = 'none';
        resize();
        startCamera();
    });

</script>
</body>
</html>
